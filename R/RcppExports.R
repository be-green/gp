# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Finds the roots of a function that takes a double vector as input
#' @param f function to find the roots of
#' @param intervals matrix of intervals to search over
#' @param tol tolerance for what is equivalent to zero
#' @param max_iter max number of iterations
#' @details Binary search (bisection) to find a
#' root of f in the interval [a, b]
#' for a vector
NULL

#' Marginal utility
#' @param c consumption
#' @param rho risk aversion
NULL

#' Find roots of Euler Equation
#' @param c_now this period's consumption
#' @param c_tp1 next period's consumption
#' @param x cash on hand
#' @param R risk free rate
#' @param G growth rate of income
#' @param sigma_n sd of log permanent income
#' @param sigma_u sd of log temp. income
#' @param beta time discount factor
#' @export
NULL

#' Draw a random matrix of bernoullis
#' @param p probability of a 0
#' @param N number of rows
#' @param T number of cols
#' @export
#' @details the probability is of a _zero_ not a one
#' because we are generating the probability of zero
#' income and it makes it easier, even though this is
#' non-standard.
NULL

#' Linear interpolation
#' @param z input parameter to linearly interpolate the x coordinates
#' @param c output vector to weight based on the input
#' @details Returns a matrix of linearly interpolated values
#' @export
linterp <- function(x, z, c) {
    .Call(`_gp_linterp`, x, z, c)
}

#' Computes the 2D Gaussian quadrature rule of order 12
#' @param mu_n mean of permanent shocks
#' @param sigma sd of permanent shocks
#' @param mu_u mean of temp shocks
#' @param sigma_u sd of temp shocks
#' @export
gh_quadrature <- function(mu_n, sigma_n, mu_u, sigma_u, nodes2D, weights2D) {
    invisible(.Call(`_gp_gh_quadrature`, mu_n, sigma_n, mu_u, sigma_u, nodes2D, weights2D))
}

#' Computes difference between expected marginal utility and
#' current marginal utility
#' @param c_now current consumption
#' @param x current cash on hand
#' @param c_next proposed next consumption
#' @param const_scale_coh cash on hand scale param (see paper)
#' @param const_add_coh cash on hand addition param (see paper)
#' @param const_scale_consump consumption scale param (see paper)
#' @param weights Weights for weighted average from Gauss-Hermite
#' quadrature
#' @param R risk free rate
#' @param p_noinc probability of income equal to 0
#' @param beta discount factor
#' @param rho CRRA risk aversion parameter
#' @export
net_euler_diff <- function(c_now, x, c_next, const_scale_coh, const_add_coh, const_scale_consump, weights, R, p_noinc, beta, rho) {
    .Call(`_gp_net_euler_diff`, c_now, x, c_next, const_scale_coh, const_add_coh, const_scale_consump, weights, R, p_noinc, beta, rho)
}

#' Function just for testing quadrature
nw <- function(sigma_n, sigma_u) {
    .Call(`_gp_nw`, sigma_n, sigma_u)
}

#' Get full consumption rule
#' @param x cash on hand grid
#' @param sigma_n standard deviation of log permanent income
#' @param sigma_u standard deviation of log transitory income
#' @param gamma_0 intercept of retirement MPC
#' @param gamma_1 slope of retirement MPC in cash on hand
#' @param R risk free rate
#' @param G permanent income growth rate
#' @param T number of years
#' @param beta time discount factor
#' @export
consumption_rule <- function(x, G, sigma_n, sigma_u, gamma_0, gamma_1, R, p_noinc, beta, rho) {
    .Call(`_gp_consumption_rule`, x, G, sigma_n, sigma_u, gamma_0, gamma_1, R, p_noinc, beta, rho)
}

#' Simulate N asset draws from log normal distribution
#' @param N number of draws
#' @param mu mean of distribution
#' @param sigma sd of distribution
#' @export
simulate_assets <- function(N, mu, sigma) {
    .Call(`_gp_simulate_assets`, N, mu, sigma)
}

#' Simulate income process
#' @param N number of simulated agents
#' @param T number of time periods
#' @param G vector of growth rates (levels)
#' @param sigma_n standard deviation of permanent income shocks
#' @param sigma_u standard deviation of temporary income shocks
#' @param p_noinc probably income is equal to zero
#' @export
simulate_income <- function(N, T, P_init, G, sigma_n, sigma_u, p_noinc) {
    .Call(`_gp_simulate_income`, N, T, P_init, G, sigma_n, sigma_u, p_noinc)
}

#' Consume out of cash on hand
#' @param x cash on hand per unit of permanent income
#' @param x_grid grid we are using for linear interpolation
#' @param cr optimal consumption rule
#' solved for with consumption_rule function
#' @details This computes consumption given income
#' assets and return on assets by first computing cash
#' on hand and then passing to the optimal consumption
#' rule.
#' @export
consume <- function(x, x_grid, cr, t) {
    .Call(`_gp_consume`, x, x_grid, cr, t)
}

#' Simulate consumption / savings lifecycle problem
#' @param N number of simulations
#' @param T number of time periods
#' @param x_grid grid of permanent income we use for consumption rule
#' @param N_shock matrix of permanent income shocks
#' @param U_shock matrix of temporary income shocks
#' @param G growth of permanent income
#' @param sigma_n sd of permanent income
#' @param sigma_u sd temporary income shocks
#' @param mu_a average log starting assets
#' @param sigma_a sd of log starting assets
#' @param p_noinc probability that income is zero
#' @param R gross return on assets
#' @param beta time discount factor
#' @param rho CRRA risk aversion
#' @export
simulate_lifecycle <- function(N, T, x_grid, N_shock, U_shock, P, init_x, G, sigma_n, sigma_u, gamma_0, gamma_1, R, p_noinc, beta, rho) {
    .Call(`_gp_simulate_lifecycle`, N, T, x_grid, N_shock, U_shock, P, init_x, G, sigma_n, sigma_u, gamma_0, gamma_1, R, p_noinc, beta, rho)
}

